---
title: '''变量对象、执行上下文与调用栈'''
date: 2017-08-14
tags:
---

### 执行上下文
上下文环境：函数调用的时候产生，每次调用函数，都会产生一个新的执行上下文环境，程序执行之前，会生成全局上下文环境，所有的变量都在里面存储着；并在程序执行时，对其中的变量赋值。

执行上下文的生命周期分为创建阶段和执行阶段
创建阶段：创建变量对象、建立作用域链，以及确定this的指向
执行阶段：完成变量赋值、函数引用、执行其他代码

js在执行时如何找到我们定义的函数和变量,这需要了解变量对象的创建过程和执行过程，如下：

### 变量对象
变量对象（variable Object，缩写为VO）是一个抽象概念中的对象，用于存储执行上下文中的：

  1.建立参数arguments对象，建立属性及赋值<br/>
  2.变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。<br/>
  3.函数声明，以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。

### 活动对象（AO）
  上面创建的变量对象，在上下文执行执行阶段就变成了活动对象，其实是同一个对象的不同阶段，这个阶段会完成赋值。<br/>
用两个例子来说明一般变量和函数在创建阶段和执行阶段的过程：

  1.变量提升
  
    function foo(){
        console.log(a);
        var a=1;
        console.log(a);
        console.log(b);
    }
    foo();  //依次输出 undefined/1/"b is not defined"

  
  2.来看一下函数提升的情况：
  
    function foo(){
        func();
        var func = function(){
            console.log("func的函数表达式");  //<ref0>
        };
        func();
        function func(){
            console.log("func的函数声明");    //<ref1>
        };
        func();
        function func(){
            console.log("同名func的函数声明"); //<ref2>
        };
    }
    //foo();  //依次输出 "同名func的函数声明"/"func的函数表达式"/"func的函数表达式"
    
    建立过程：
    1.VO对象{}
    2.遇到第一次声明了func变量将func加入到VO中,VO:{func:undefined}
    3.遇到第一次func的函数声明，VO中存在同名的变量，引用覆盖值为undefined的同名变量，VO:{func:<ref1>}
    4.遇到第二次func的函数声明，VO中存在同名的变量，覆盖前面的引用 VO:{func:<ref2>}
    
    执行过程：
    从VO中读取值，并修改，此时VO装换状态变成AO
    1.读取值为ref2的引用，所以输出"同名func的函数声明"
    2.执行func的函数表达式，将修改引用的值，VO:{func:<ref0>},输出"func的函数表达式"
    3.变量的值不再修改，同样输出"func的函数表达式"
    
    
    function foo(){
        func();
        function func(){
            console.log("func的函数声明");  //<ref1>
        };
        
        var func = function(){
            console.log("func的函数表达式"); //<ref0>
        };
        func();
    }
    foo1(); //依次输出：func的函数声明/func的函数表达式
    
    建立过程：
    1.VO对象{}
    2.遇到第一次func函数声明，将func加入到VO中,VO:{func:<ref1>}
    3.遇到func的函数表达式，VO中存在同名的变量，防止同名的引用被修改，所以跳过，VO:{func:<ref1>}
    
    执行过程：
    1.读取值为ref1的引用，所以输出"func的函数声明"
    2.执行func的函数表达式，将修改引用的值，输出"func的函数表达式"

通过以上例子可以解释变量提升和函数提升了，并且第一个例子可以说明函数声明比函数表达式优先级更高。


### 注意
由于函数声明提升，所以下面这样的代码不应该出现，在ES中这是无效的语法，会出现意想不到的现象，有些浏览器会忽略condition，返回第二个声明

    var condition;
    if(condition){
      function func(){
        alert("condition1");
      }
    }else{
      function func(){
        alert("condition2");
      }
    }



### 函数调用栈
  js中会产生多个上下文环境，js引擎以堆栈的方式处理它们。每次函数在调用时产生一个上下文环境，并把该上下文环境压入栈中，即函数调用栈，栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。
  当一个函数被调用完成之后，其执行上下文环境将出栈被销毁，其中的变量也会被同时销毁。有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁——闭包（闭包的核心内容）


参考链接：
http://www.cnblogs.com/wangfupeng1988/tag/%E5%8E%9F%E5%9E%8B/




