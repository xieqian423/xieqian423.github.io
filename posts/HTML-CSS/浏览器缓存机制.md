# 浏览器缓存机制
是指通过 HTTP 协议头里的 Cache-Control (或 Expires) 和 Last-Modified (或 Etag) 等字段来控制文件缓存的机制。


## 文档过期
Cache-Control(HTTP1.1) 用于控制文件在本地缓存有效时长。在有效期内可任意使用，无需与服务器联系。

    比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒 (从发出请求算起)。
    在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。

Expires 是 HTTP1.0中的标准字段，向下兼容，值一个绝对的时间点。 与Cache-Control一样，控制缓存有效日期。当这两个字段同时出现时，Cache-Control 是高优化级的。

【注意】

Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。

Cache-Control: no-store：这个才是响应不被缓存的意思。

## 服务器再验证
 
   缓存过期不代表与原始服务器当前活跃的文档有区别，所以需要进行核对，询问服务器文档是否发生变化。

 用条件方法进行再验证：

### Date再验证

下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。
如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。

 Last-Modified 是标识文件在服务器上的最新更新时间，第一次请求时服务器，响应头中会附带该字段。
Cache-Control 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。

### 实体标签再验证

 有写文档可能会被修改，但该修改并不重要，不需要重新下载
Etag 的取值是一个对文件进行标识的特征字串。

 在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。

Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。
两个同时使用时，只要满足基中一个条件，就认为文件没有更新。


### 另外有两种特殊的情况：

1. 手动刷新页面(F5)

 浏览器会直接认为缓存已经过期(可能缓存还没有过期)，在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。

2. 强制刷新页面(Ctrl+F5)
	
  浏览器会直接忽略本地的缓存(有缓存也会认为本地没有缓存)，在请求中加上字段：Cache-Control:no-cache (或 Pragma:no-cache)，发包向服务重新拉取文件。

## 缓存的好处
当Web请求到达缓存时，缓存从本地副本中提取这个副本内容而不需要经过服务器。这带来了以下优点：

1. 缓存减少了冗余的数据传输，节省流量
2. 缓存缓解了带宽瓶颈问题。不需要更多的带宽就能更快加载页面
3. 缓存缓解了瞬间拥塞，降低了对原始服务器的要求。
4. 缓存降低了距离延时， 因为从较远的地方加载页面会更慢一些。

## 缓存种类
1. 私有缓存

 私有缓存只针对专有用户，所以不需要很大空间，廉价。Web浏览器中有内建的私有缓存

2. 公有缓存

 公有缓存是特殊的共享代理服务器，被称为缓存代理服务器或代理缓存（反向代理的一种用途）。公有缓存会接受来自多个用户的访问，所以通过它能够更好的减少冗余流量。
比如一个公司的用户同时访问某个热点新闻。

关于更多浏览器缓存介绍请参考：

[H5 缓存机制浅析 移动端 Web 加载性能优化]（http://www.cnblogs.com/bugly/p/5039153.html）
